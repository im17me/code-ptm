# NoSQL数据库
## 为什么要使用NoSQL数据库
* 解决应用服务器的cpu和内存压力

* 减少io的读操作，减轻io的压力

* 关系型数据库的扩展性不强，难以改变表结构



## 优点
* NoSQL数据库没有关联关系，数据结构简单，拓展表比较容易

* NoSQL读取速度快，对较大数据处理快


## 适用场景

* 数据高并发的读写

* 海量数据的读写

* 对扩展性要求高的数据


## 不适用场景
* 需要事务支持（非关系型数据库）

* 基于sql结构化查询储存，关系复杂


## 使用场景

* 配合关系型数据库做高速缓存

* 缓存高频次访问的数据，降低数据库io

* 分布式架构，做session共享

* 可以持久化特定数据。

* 利用zset类型可以存储排行榜

* 利用list的自然时间排序存储最新n个数据



## Redis相比Memcached有哪些优势？

* memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型

* redis的速度比memcached快很多

* redis可以持久化其数据



## Redis和Memchached区别

### 特性比较

|数据库|延迟|QPS|可用性|一致性|扩展性|海量存储|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|Redis|一般|一般|极好|极好|极好|极好|
|Memcached|未知|未知|未知|未知|未知|未知|


### Redis特性
#### 优点

* redis：单线程+io多路复用，检查文件描述的就绪状态

* 读写性能优异，Redis能读的速度是110000次/s,写的速度是81000次/s 

* 支持数据持久化，支持AOF和RDB两种持久化方式

* 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离

* Redis是一个开源的key—value型数据库，数据结构支持string、list、set、zset和hash类型数据

* Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行，redis为了保证效率会定期持久化数据

* Redis还支持 publish/subscribe, 通知, key 过期等等特性

* Redis支持实时的数据备份，及时宕机，也可以把数据恢复过来


#### 缺点

* 由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。

* redis是单线程的，单台服务器无法充分利用多核服务器的CPU

* redis的主从复制采用全量复制，复制过程中主机会fork出一个子进程对内存做一份快照，并将子进程的内存快照保存为文件发送给从机，这一过程需要确保主机有足够多的空余内存。若快照文件较大，对集群的服务能力会产生较大的影响，而且复制过程是在从机新加入集群或者从机和主机网络断开重连时都会进行，也就是网络波动都会造成主机和从机间的一次全量的数据复制，这对实际的系统运营造成了不小的麻烦

* Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费




*** 

### Memchached特性
#### 优点
* Memchached：多线程+锁

* Memcached是内存缓存，在读写速度上会比普通files时快很多

* 可以解决多个服务器公用session的难题

#### 缺点

* session数据都保存在memory中，持久化方面有所欠缺，但对session数据来说不是问题

* 也可以用其它的持久化系统存储sessions，例如：redis，ttserver

* 高性能高并发场景，cookies的效率比session更好很多，因此，很多大网站都会用cookies解决会话共享问题



***


## Redis常用的数据类型
### String、Hash、Set、List、SortedSet、pub/sub、Transactions。
* 1、String：Strings就是一个最最简单的Key-Value形式存储的变量。其中Value既可以是数字也可以是字符串。其实现方式是在Redis内部默认存储一个字符串，被redisObject引用，当检测到数字操作如自增自减incr、decr等等命令时，自动转化为数字进行计算，计算完毕后再转化为String存储起来。

* 2、Hash:Hash存储是键值对的value。即Key-Hash，而Hash又是一个k-v的结构，如果使用的Memcached，则需要把整个Hash打包存储在内存中，如果需要查询其中某个值，还要全部取出整个Hash，再查找对应值。而Redis可以直接通过命令获取到Value，大大提高了性能。 其实现原理：当成员较少时，Redis为了节约内存会采用类似一维数组的紧凑存储，而当对象较多时，则直接转为HashMap存储。

* 3、Set：Set是一个无序的天然去重的集合，即Key-Set。此外还提供了交集、并集等一系列直接操作集合的方法，对于求共同好友、共同关注什么的功能实现特别方便。其底层是靠HashMap实现的，其中value为null；

* 4、List：List是一个有序可重复的集合，其遵循FIFO的原则，底层是依赖双向链表实现的，因此支持正向、反向双重查找。通过List，我们可以很方面的获得类似于最新回复这类的功能实现。

* 5、SortedSet：类似于java中的TreeSet，是Set的可排序版。此外还支持优先级排序，维护了一个score的参数来实现。其底层主要依赖HashMap来实现的，通过维持插入的数值和Score优先级的映射来进行排序。

* 6、pub/sub：发布订阅，类似于消息队列mq。可以选择对某个Key进行订阅，一旦这个key发布了一些消息，则所有订阅了这个Key的对象就可以收到这个消息。主要可以用在实时消息系统上，例如聊天之类的。

* 7、Transactions：NoSQL不支持事务，但是通过提供了打包执行的功能，即这个包里面的所有命令必须要一起执行，此外还可以锁定某个Key，在打包执行命令时如果检测到这个Key发生了变化，则直接回滚。

## Redis的常用应用场景
### redis使用内存提供存储，通过持久化功能保存数据。且针对request是单线程操作。这一系列特点使得redis具有十分神奇的功能。

### 1、查找最新的回复。
* 如果在传统的关系型数据库，这就需要使用select * from table where name="" order by time desc limit 100；这十分消耗数据库性能，但是通过Redis，就可以直接在Redis里面通过Id创建一个List，指定长度1w，当需要查找时，直接输出该list的后100条记录。

### 2、排行问题
* 常见的排行问题，例如最热话题、游戏排名等等，这些都可以通过Redis来轻松实现，直接使用ZRank即可得到。

### 3、删除过期数据
* Redis不是真正意义上的可持久化数据库，可以给数据加上一个有效时间，在有效时间超过时，Redis会自动删除对应数据。



